抽象类是普通的类与接口之间的一种中庸之道。

通用接口，例如基类中的“哑”方法；——》不同的子类可以用不同的方式表示此接口；
|
创建该类的对象没有任何意义——》通过调用该类中的方法产生错误达到这个目的。
|
问题是，这样做会将错误信息延迟到运行时才获得
|
所以，最好是在编译时捕获这些问题；
|
为此，Java提供一个叫做“抽象方法”的机制；-仅有声明而没有方法体；
abstract void f(){}
|
包含“抽象方法”的类叫做“抽象类”；-（如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的，否则编译器就会报错）
abstract class Instrument{}

abstract关键字允许人们在类中创建一个或多个没有任何定义的方法——提供了接口部分，但是没有提供任何相应的具体实现，这些实现是由此类的继承者创建的。
interface关键字产生一个完全抽象的类，它根本就没有提供任何具体实现,允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体。

一个接口表示：“所有实现了该特定接口的类看起来都像这样”。
因此，接口被用来建立类与类之间的协议。

但是，interface不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继变种的特性。

要让一个类遵循某个特定接口（或者是一组接口），需要使用implements关键字，它表示：
interface只是它的外貌，但是现在我要声明它是如何工作的。除此之外，它看起来还很像继承。

可以在interface前面添加public,如果不添加public,则它只具有包访问权限。接口也可以包含域，但是这些域都是static和final的。

在实现interface中的方法都是public的（即在implements中）。

完全解耦
|
只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类；
接口可以在很大程度上放宽这种限制，可以将方法应用于不在此继承结构中的某个类；
|
策略设计模式  ： 创建一个能够根据所传递的参数对象的不同而具有不同行为的方法；
|
public static void process(Processor p,Object s){} （p175）
process方法可以接受任何类型的Processor，并将其应用到一个Object对象上；
策略包含变化的部分，策略就是传递进去的参数对象，这里，Processor对象就是一个策略；
|
适配器设计模式  ： 适配器中的代码将接受你所拥有的接口，并产生你所需要的接口；
Apply.process(new FilterAdapter(new LowPass(1.0)),new Waveform()) (p178)
|
FilterAdapter构造器接受你所拥有的接口Filter,然后生成具有你所需要的Processor接口的对象。
|
将接口从具体实现中解耦使得接口可以应用于多种不同的实现，因此代码也就更具可复用性；










