抽象类是普通的类与接口之间的一种中庸之道。

通用接口，例如基类中的“哑”方法；——》不同的子类可以用不同的方式表示此接口；
|
创建该类的对象没有任何意义——》通过调用该类中的方法产生错误达到这个目的。
|
问题是，这样做会将错误信息延迟到运行时才获得
|
所以，最好是在编译时捕获这些问题；
|
为此，Java提供一个叫做“抽象方法”的机制；-仅有声明而没有方法体；
abstract void f(){}
|
包含“抽象方法”的类叫做“抽象类”；-（如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的，否则编译器就会报错）
abstract class Instrument{}

abstract关键字允许人们在类中创建一个或多个没有任何定义的方法——提供了接口部分，但是没有提供任何相应的具体实现，这些实现是由此类的继承者创建的。
interface关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。

一个接口表示：“所有实现了该特定接口的类看起来都像这样”。
因此，接口被用来建立类与类之间的协议。

但是，interface不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继变种的特性。

要让一个类遵循某个特定接口（或者是一组接口），需要使用implements关键字，它表示：
interface只是它的外貌，但是现在我要声明它是如何工作的。除此之外，它看起来还很像继承。

在实现interface中的方法都是public的（即在implements中）。









