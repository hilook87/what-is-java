extends
自动得到基类中所有的域和方法；

在继承类中，
可以修改基类的方法，（在其中可以用super调用基类的方法）；
可以新增方法；

为了继承，一般的规则是将所有数据成员都指定为private,将所有方法指定为public（protected成员也可以借助导出类来访问）;

导出类对象的初始化：
当创建了一个导出类的对象时，该对象包含了一个基类的子对象；
这个子对象与你用基类创建的对象是一样的。
二者区别在于，后者来自外部，而基类的子对象被包装在导出类对象内部。

Java会自动在导出类的构造器中插入对基类构造器的调用；
但是如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式的编写调用基类构造器的语句；

@Override,确保是覆写，而不是重载；

“为新的类提供方法”并不是继承技术中最重要的方面，
其最重要的方面是用来“表现新类和基类之间的关系”。

向上转型：
public static void tune(Instrument i){
    //...
    i.play(Note.MIDDLE_C);
}
//...
Wind flute = new Wind();
tune(flute);
运行结果：
Wind.play() MIDDLE_C
|
多态：不管导出类的存在，编写的代码只与基类打交道；
但是，上述例子中，编译器怎样才能知道这个Instrument引用指向的是Wind对象，而不是Brass对象或是Stringed对象呢？——》实际上，编译器无法得知；
|
解决办法：后期绑定。——》编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。——》在对象中安置某种“类型信息”。


