内部类：将一个类的定义放在另一个类的定义内部。
（内部类和组合是完全不同的概念）

把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。
且内部类了解外围类，并能与之通信。内部类能访问外围对象的所有成员和所有元素；

1，在方法里面使用内部类的时候，与使用普通类没什么不同；
2，更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用；
|
从外部类的非静态方法之外的任意位置创建某个内部类的对象，具体的指明这个对象的类型：OuterClassName.InnerClassName；->例子：Parcel2.Contents c = q.contents()
生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this;->例子：例如在一个内部类的一个方法中，return DotThis.this;
要告知某些其它对象去创建其某个内部类的对象，必须在new表达式中提供对其它外部类对象的引用，使用.new语法；->例子：DotNew.Inner dni = dn.new Inner();
|
嵌套类：——》作用之一：使用这个类来做测试，但是不必在发布的产品中包含它(p203)；
将内部类声明为static;->例子，如果再将相关方法也声明为static(例如：contents()),Contents c = contents();
|
接口内部的类：——》作用之一：想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用；
正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分；
放到接口中的任何类都自动是public和static（想象成接口中的域都是static和final的），所以在接口中的内部类是嵌套类；
嵌套类置于接口的命名空间内（相当于就是接口中的域吧），这并不违法接口规则；
甚至可以在内部类中实现其外围接口；
|
多层内部类(p203)；


内部类的继承:
需要使用一些特殊的语法对其构造器初始化：
class WithInner{
  class Inner{}
}
public class InheritInner extends WithInner.Inner{
  //! InheritInner(){}   //Won't compile
  InheritInner(WithInner wi){
    wi.super();
  }
  public static void main(String[] args){
    WithInner wi = new WithInner();
    InheritInner ii = new InheritInner(wi);
  }
}


内部类的覆盖：
1，“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用；
2，当然明确地继承某个内部类也是可以的；
   public class Yolk extends Egg2.Yolk{}


局部内部类：
不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当年代码块内的常量，以及此外围类的所有成员；
局部内部类 VS 匿名内部类
这两者都是在方法体中定义；
局部内部类中可以有构造器，匿名内部类中不能有构造器（只能有{}《——“初始化”中的“非静态实例初始化”）
使用局部内部类而不是匿名内部类的唯一理由是：我们需要一个已命名的构造器或者需要重载构造器，而匿名内部类只能用于实例初始化；——》需要不止一个该内部类的对象；


内部类标识符：
内部类生成的class文件名字，例如，匿名内部类：LocalInnerClass$1.class《——编译器会简单的产生一个数字作为其标识符，加在$后面；













